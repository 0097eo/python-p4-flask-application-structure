# Building Flask Applications

## Learning Goals

- Describe the components of a web application framework.
- Build and run a Flask application on your computer.
- Manipulate and test the structure of a request object.

***

## Key Vocab

- **Web Framework**: software that is designed to support the development of
  web applications. Web frameworks provide built-in tools for generating web
  servers, turning Python objects into HTML, and more.
- **Extension**: a package or module that adds functionality to a Flask
  application that it does not have by default.
- **Request**: an attempt by one machine to contact another over the internet.
- **Client**: an application or machine that accesses services being provided
  by a server through the internet.
- **Web Server**: a combination of software and hardware that uses Hypertext
  Transfer Protocol (HTTP) and other protocols to respond to requests made
  over the internet.
- **Web Server Gateway Interface (WSGI)**: an interface between web servers
  and applications.
- **Template Engine**: software that takes in strings with tokenized
  values, replacing the tokens with their values as output in a web browser.

***

## Introduction

It's finally time to create our first Flask application. We'll start this
lesson with your standard "text output in the browser" application, but we'll
also extend a bit further to explore **routing**, creating Flask development
servers, and debugging in the browser.

***

## Initializing an Application

Flask is a web framework, but it is first and foremost a _Python_ framework.
To start any Flask application, you need to create an instance of the `Flask`
class. Your web server- whether you run it from Werkzeug, Flask, or another
library entirely- interacts with this `Flask` instance using WSGI.

Before we start, make sure to enter your virtual environment with `pipenv install
&& pipenv shell`.

Open `app/flask_app.py` and enter the following code:

```py
#!/usr/bin/env python3

from flask import Flask

app = Flask(__name__)

```

The `Flask` class constructor only requires the name of the primary module or
package to be interpreted as the application. Flask uses this to figure out
where the application is and where its important files will be. As some of these
will not be `.py` files and might not have any `.py` files in their directory,
Flask needs to set up an application structure that allows it to see everything.

For the purposes of our curriculum, this argument will always be `__name__`,
which refers to the name of the current module.

***

## Routing Views

### Routing

When clients send requests to our application's server, they are forwarded to
our Flask application instance. This instance will receive requests for many
different resources, located at different Uniform Resource Locations (URLs).
To map these URLs to Python functions, we need to define **routes**.

**Routing** is the association of URLs and the code that should execute when a
request comes in for that URL. Routing isn't just a Python concept- JavaScript,
Java, Ruby, and even newer languages like Rust and Go use routes to direct
requests to the appropriate backend code.

The easiest way to define routes with Flask is through use of the `@app.route`
decorator:

```py
# append to app/flask_app.py

@app.route('/')
def index():
    return '<h1>Welcome to my page!</h1>'

```

Remember that **decorators** are functions that take functions as arguments and
return them decorated with new features. `@app.route` registers the `index()`
function with the Flask application instance `app` and creates a rule that
requests for the base URL should show our index: a page with a header that says
"Welcome to my page!"

### Views

We call functions that map to URLs **views**. This is easy to remember-
everything you _view_ in your application is generated by a **view** (though
there are certainly many invisible things going on in views as well).

A view returns the response that the client delivers to the user. Our `index()`
view returns a simple string of HTML code, but we will see throughout Phase 4
that views can also contain forms, code to ensure cybersecurity, and much more.

### Variable Routes

Navigate to your favorite social media site and take a look at the URL. The base
will represent the index or homepage for the application. Navigate to a user
profile and take another look at the URL:

![Screenshot of NASA Twitter profile with URL twitter.com/NASA](
https://curriculum-content.s3.amazonaws.com/python/twitter_nasa_screenshot.png)

"twitter.com" is clearly a fixed portion of the URL- it's everywhere! There are
other pieces, though, that it wouldn't make sense to hard-code into our
application. "NASA", for instance, is the username for one out of millions of
users on the site. Managing views for that many users would be impossible!

Lucky for us, Flask allows us to parameterize different parts of our routes.
When we interpolate these into strings or use them to retrieve records from a
database, we can create flexible, dynamic applications:

```py
# append to app/flask_app.py

@app.route('/<username>')
def user(username):
    return f'<h1>Profile for {username}</h1>'

```

Anything included in the route passed to the `app.route` decorator with pointy
brackets `<>` surrounding it will be passed to the decorated function as a
parameter. We can make sure that the username is a valid `string`, `int`,
`float`, or `path` (string with slashes) by specifying this in the route:

```py
# modify user() in app/flask_app.py

@app.route('/<string:username>')
def user(username):
    return f'<h1>Profile for {username}</h1>'

```

Now we're ready to run our application.

***

## The Flask Development Web Server

***

## Lesson Section

Lorem ipsum dolor sit amet. Ut velit fugit et porro voluptas quia sequi quo
libero autem qui similique placeat eum velit autem aut repellendus quia. Et
Quis magni ut fugit obcaecati in expedita fugiat est iste rerum qui ipsam
ducimus et quaerat maxime sit eaque minus. Est molestias voluptatem et nostrum
recusandae qui incidunt Quis 33 ipsum perferendis sed similique architecto.

```py
# python code block
print("statement")
# => statement
```

```js
// javascript code block
console.log("use these for comparisons between languages.")
// => use these for comparisons between languages.
```

```console
echo "bash/zshell statement"
# => bash/zshell statement
```

<details>
  <summary>
    <em>Check for understanding text goes here! <code>Code statements go here.</code></em>
  </summary>

  <h3>Answer.</h3>
  <p>Elaboration on answer.</p>
</details>
<br/>

***

## Instructions

This is a **test-driven lab**. Run `pipenv install` to create your virtual
environment and `pipenv shell` to enter the virtual environment. Then run
`pytest -x` to run your tests. Use these instructions and `pytest`'s error
messages to complete your work in the `lib/` folder.

Instructions begin here:

- Make sure to specify any class, method, variable, module, package names
  that `pytest` will check for.
- Any other instructions go here.

Once all of your tests are passing, commit and push your work using `git` to
submit.

***

## Conclusion

Conclusion summary paragraph. Include common misconceptions and what students
will be able to do moving forward.

***

## Resources

- [Resource 1](https://www.python.org/doc/essays/blurb/)
- [Reused Resource][reused resource]

[reused resource]: https://docs.python.org/3/
